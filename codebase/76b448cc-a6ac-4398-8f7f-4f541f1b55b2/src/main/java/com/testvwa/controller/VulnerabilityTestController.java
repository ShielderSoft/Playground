package com.testvwa.controller;

import com.testvwa.util.SecurityUtils;
import org.apache.log4j.Logger;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.*;
import java.net.URL;
import java.sql.*;

@Controller
@RequestMapping("/test")
public class VulnerabilityTestController {

    private static final Logger logger = Logger.getLogger(VulnerabilityTestController.class);

    @RequestMapping("/")
    public String testHome() {
        return "test-home";
    }

    @RequestMapping("/xss")
    @ResponseBody
    public String testXSS(@RequestParam String input) {
        // VULNERABILITY: Reflected XSS
        return "<h1>Hello " + input + "!</h1><p>Your input was: " + input + "</p>";
    }

    @RequestMapping("/sqli")
    @ResponseBody
    public String testSQLInjection(@RequestParam String id) {
        try {
            // VULNERABILITY: SQL Injection
            String sql = "SELECT * FROM users WHERE id = " + id;
            logger.info("Executing SQL: " + sql);
            
            // Simulate database query
            return "Query executed: " + sql + "<br>User data would be displayed here.";
            
        } catch (Exception e) {
            return "SQL Error: " + e.getMessage();
        }
    }

    @RequestMapping("/lfi")
    @ResponseBody
    public String testLFI(@RequestParam String file) {
        try {
            // VULNERABILITY: Local File Inclusion
            File targetFile = new File(file);
            
            if (targetFile.exists()) {
                BufferedReader reader = new BufferedReader(new FileReader(targetFile));
                StringBuilder content = new StringBuilder();
                String line;
                
                while ((line = reader.readLine()) != null) {
                    content.append(line).append("<br>");
                }
                reader.close();
                
                return content.toString();
            } else {
                return "File not found: " + file;
            }
            
        } catch (Exception e) {
            return "Error reading file: " + e.getMessage();
        }
    }

    @RequestMapping("/rfi")
    @ResponseBody
    public String testRFI(@RequestParam String url) {
        try {
            // VULNERABILITY: Remote File Inclusion / SSRF
            URL remoteUrl = new URL(url);
            BufferedReader reader = new BufferedReader(new InputStreamReader(remoteUrl.openStream()));
            
            StringBuilder content = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line).append("<br>");
            }
            reader.close();
            
            return content.toString();
            
        } catch (Exception e) {
            return "Error fetching remote content: " + e.getMessage();
        }
    }

    @RequestMapping("/cmd")
    @ResponseBody
    public String testCommandInjection(@RequestParam String cmd) {
        // VULNERABILITY: Command Injection
        return SecurityUtils.executeCommand(cmd);
    }

    @RequestMapping("/idor")
    @ResponseBody
    public String testIDOR(@RequestParam String userId) {
        // VULNERABILITY: Insecure Direct Object Reference
        return "Accessing user data for ID: " + userId + 
               "<br>User: admin<br>Email: admin@testvwa.com<br>SSN: 123-45-6789";
    }

    @RequestMapping("/info")
    @ResponseBody
    public String testInfoDisclosure() {
        // VULNERABILITY: Information Disclosure
        return "<pre>" + SecurityUtils.getSystemInfo() + "</pre>";
    }

    @RequestMapping("/weak-crypto")
    @ResponseBody
    public String testWeakCrypto(@RequestParam String data) {
        // VULNERABILITY: Weak cryptography
        String encrypted = SecurityUtils.encrypt(data);
        String decrypted = SecurityUtils.decrypt(encrypted);
        
        return "Original: " + data + "<br>" +
               "Encrypted: " + encrypted + "<br>" +
               "Decrypted: " + decrypted;
    }

    @RequestMapping("/deserialization")
    @ResponseBody
    public String testDeserialization(@RequestParam String data) {
        // VULNERABILITY: Insecure Deserialization
        try {
            Object obj = SecurityUtils.deserializeObject(data);
            return "Deserialized object: " + obj.toString();
        } catch (Exception e) {
            return "Deserialization error: " + e.getMessage();
        }
    }

    @RequestMapping("/path-traversal")
    @ResponseBody
    public String testPathTraversal(@RequestParam String path) {
        try {
            // VULNERABILITY: Path Traversal
            String basePath = "C:\\uploads\\";
            File file = new File(basePath + path);
            
            if (file.exists()) {
                BufferedReader reader = new BufferedReader(new FileReader(file));
                StringBuilder content = new StringBuilder();
                String line;
                
                while ((line = reader.readLine()) != null) {
                    content.append(line).append("<br>");
                }
                reader.close();
                
                return content.toString();
            } else {
                return "File not found: " + file.getAbsolutePath();
            }
            
        } catch (Exception e) {
            return "Error: " + e.getMessage();
        }
    }

    @RequestMapping("/session-fixation")
    public String testSessionFixation(@RequestParam(required = false) String sessionId, 
                                    HttpServletRequest request) {
        // VULNERABILITY: Session Fixation
        if (sessionId != null) {
            logger.info("Setting session ID to: " + sessionId);
            // In a real app, this would set the session ID
        }
        
        return "redirect:/dashboard";
    }

    @RequestMapping("/weak-session")
    @ResponseBody
    public String testWeakSession() {
        // VULNERABILITY: Weak session management
        String sessionToken = SecurityUtils.generateSessionToken();
        return "Generated session token: " + sessionToken;
    }

    @RequestMapping("/backdoor")
    @ResponseBody
    public String testBackdoor(@RequestParam String username, @RequestParam String password) {
        // VULNERABILITY: Backdoor authentication
        if (SecurityUtils.authenticateUser(username, password)) {
            return "Access granted! Welcome " + username;
        } else {
            return "Access denied.";
        }
    }

    @RequestMapping("/redirect")
    public void testOpenRedirect(@RequestParam String url, HttpServletResponse response) {
        try {
            // VULNERABILITY: Open Redirect
            response.sendRedirect(url);
        } catch (Exception e) {
            logger.error("Redirect error", e);
        }
    }

    @RequestMapping("/log-injection")
    @ResponseBody
    public String testLogInjection(@RequestParam String data) {
        // VULNERABILITY: Log Injection
        logger.info("User input: " + data);
        return "Data logged: " + data;
    }

    @RequestMapping("/xml-bomb")
    @ResponseBody
    public String testXMLBomb(@RequestBody String xml) {
        // VULNERABILITY: XML Bomb / Billion Laughs Attack
        try {
            javax.xml.parsers.DocumentBuilderFactory factory = 
                javax.xml.parsers.DocumentBuilderFactory.newInstance();
            javax.xml.parsers.DocumentBuilder builder = factory.newDocumentBuilder();
            
            org.w3c.dom.Document doc = builder.parse(
                new java.io.ByteArrayInputStream(xml.getBytes()));
            
            return "XML parsed successfully. Root: " + doc.getDocumentElement().getNodeName();
            
        } catch (Exception e) {
            return "XML parsing error: " + e.getMessage();
        }
    }
}
